<<<<<<< HEAD
<<<<<<< HEAD
import bisect
import re
import unicodedata
from typing import Optional, Union

from . import idnadata
from .intranges import intranges_contain

_virama_combining_class = 9
_alabel_prefix = b"xn--"
_unicode_dots_re = re.compile("[\u002e\u3002\uff0e\uff61]")


class IDNAError(UnicodeError):
    """Base exception for all IDNA-encoding related problems"""

=======
from . import idnadata
=======
>>>>>>> 903c694 (inital commit)
import bisect
import re
import unicodedata
from typing import Optional, Union

from . import idnadata
from .intranges import intranges_contain

_virama_combining_class = 9
_alabel_prefix = b"xn--"
_unicode_dots_re = re.compile("[\u002e\u3002\uff0e\uff61]")


class IDNAError(UnicodeError):
<<<<<<< HEAD
    """ Base exception for all IDNA-encoding related problems """
>>>>>>> ecbd90b (Initial commit)
=======
    """Base exception for all IDNA-encoding related problems"""

>>>>>>> 903c694 (inital commit)
    pass


class IDNABidiError(IDNAError):
<<<<<<< HEAD
<<<<<<< HEAD
    """Exception when bidirectional requirements are not satisfied"""

=======
    """ Exception when bidirectional requirements are not satisfied """
>>>>>>> ecbd90b (Initial commit)
=======
    """Exception when bidirectional requirements are not satisfied"""

>>>>>>> 903c694 (inital commit)
    pass


class InvalidCodepoint(IDNAError):
<<<<<<< HEAD
<<<<<<< HEAD
    """Exception when a disallowed or unallocated codepoint is used"""

=======
    """ Exception when a disallowed or unallocated codepoint is used """
>>>>>>> ecbd90b (Initial commit)
=======
    """Exception when a disallowed or unallocated codepoint is used"""

>>>>>>> 903c694 (inital commit)
    pass


class InvalidCodepointContext(IDNAError):
<<<<<<< HEAD
<<<<<<< HEAD
    """Exception when the codepoint is not valid in the context it is used"""

=======
    """ Exception when the codepoint is not valid in the context it is used """
>>>>>>> ecbd90b (Initial commit)
=======
    """Exception when the codepoint is not valid in the context it is used"""

>>>>>>> 903c694 (inital commit)
    pass


def _combining_class(cp: int) -> int:
    v = unicodedata.combining(chr(cp))
    if v == 0:
        if not unicodedata.name(chr(cp)):
<<<<<<< HEAD
<<<<<<< HEAD
            raise ValueError("Unknown character in unicodedata")
    return v


def _is_script(cp: str, script: str) -> bool:
    return intranges_contain(ord(cp), idnadata.scripts[script])


def _punycode(s: str) -> bytes:
    return s.encode("punycode")


def _unot(s: int) -> str:
    return "U+{:04X}".format(s)
=======
            raise ValueError('Unknown character in unicodedata')
=======
            raise ValueError("Unknown character in unicodedata")
>>>>>>> 903c694 (inital commit)
    return v


def _is_script(cp: str, script: str) -> bool:
    return intranges_contain(ord(cp), idnadata.scripts[script])


def _punycode(s: str) -> bytes:
    return s.encode("punycode")


def _unot(s: int) -> str:
<<<<<<< HEAD
    return 'U+{:04X}'.format(s)
>>>>>>> ecbd90b (Initial commit)
=======
    return "U+{:04X}".format(s)
>>>>>>> 903c694 (inital commit)


def valid_label_length(label: Union[bytes, str]) -> bool:
    if len(label) > 63:
        return False
    return True


def valid_string_length(label: Union[bytes, str], trailing_dot: bool) -> bool:
    if len(label) > (254 if trailing_dot else 253):
        return False
    return True


def check_bidi(label: str, check_ltr: bool = False) -> bool:
    # Bidi rules should only be applied if string contains RTL characters
    bidi_label = False
<<<<<<< HEAD
<<<<<<< HEAD
    for idx, cp in enumerate(label, 1):
        direction = unicodedata.bidirectional(cp)
        if direction == "":
            # String likely comes from a newer version of Unicode
            raise IDNABidiError("Unknown directionality in label {} at position {}".format(repr(label), idx))
        if direction in ["R", "AL", "AN"]:
=======
    for (idx, cp) in enumerate(label, 1):
=======
    for idx, cp in enumerate(label, 1):
>>>>>>> 903c694 (inital commit)
        direction = unicodedata.bidirectional(cp)
        if direction == "":
            # String likely comes from a newer version of Unicode
<<<<<<< HEAD
            raise IDNABidiError('Unknown directionality in label {} at position {}'.format(repr(label), idx))
        if direction in ['R', 'AL', 'AN']:
>>>>>>> ecbd90b (Initial commit)
=======
            raise IDNABidiError("Unknown directionality in label {} at position {}".format(repr(label), idx))
        if direction in ["R", "AL", "AN"]:
>>>>>>> 903c694 (inital commit)
            bidi_label = True
    if not bidi_label and not check_ltr:
        return True

    # Bidi rule 1
    direction = unicodedata.bidirectional(label[0])
<<<<<<< HEAD
<<<<<<< HEAD
    if direction in ["R", "AL"]:
        rtl = True
    elif direction == "L":
        rtl = False
    else:
        raise IDNABidiError("First codepoint in label {} must be directionality L, R or AL".format(repr(label)))

    valid_ending = False
    number_type: Optional[str] = None
    for idx, cp in enumerate(label, 1):
=======
    if direction in ['R', 'AL']:
=======
    if direction in ["R", "AL"]:
>>>>>>> 903c694 (inital commit)
        rtl = True
    elif direction == "L":
        rtl = False
    else:
        raise IDNABidiError("First codepoint in label {} must be directionality L, R or AL".format(repr(label)))

    valid_ending = False
<<<<<<< HEAD
    number_type = None  # type: Optional[str]
    for (idx, cp) in enumerate(label, 1):
>>>>>>> ecbd90b (Initial commit)
=======
    number_type: Optional[str] = None
    for idx, cp in enumerate(label, 1):
>>>>>>> 903c694 (inital commit)
        direction = unicodedata.bidirectional(cp)

        if rtl:
            # Bidi rule 2
<<<<<<< HEAD
<<<<<<< HEAD
=======
>>>>>>> 903c694 (inital commit)
            if direction not in [
                "R",
                "AL",
                "AN",
                "EN",
                "ES",
                "CS",
                "ET",
                "ON",
                "BN",
                "NSM",
            ]:
                raise IDNABidiError("Invalid direction for codepoint at position {} in a right-to-left label".format(idx))
<<<<<<< HEAD
            # Bidi rule 3
            if direction in ["R", "AL", "EN", "AN"]:
                valid_ending = True
            elif direction != "NSM":
                valid_ending = False
            # Bidi rule 4
            if direction in ["AN", "EN"]:
=======
            if not direction in ['R', 'AL', 'AN', 'EN', 'ES', 'CS', 'ET', 'ON', 'BN', 'NSM']:
                raise IDNABidiError('Invalid direction for codepoint at position {} in a right-to-left label'.format(idx))
=======
>>>>>>> 903c694 (inital commit)
            # Bidi rule 3
            if direction in ["R", "AL", "EN", "AN"]:
                valid_ending = True
            elif direction != "NSM":
                valid_ending = False
            # Bidi rule 4
<<<<<<< HEAD
            if direction in ['AN', 'EN']:
>>>>>>> ecbd90b (Initial commit)
=======
            if direction in ["AN", "EN"]:
>>>>>>> 903c694 (inital commit)
                if not number_type:
                    number_type = direction
                else:
                    if number_type != direction:
<<<<<<< HEAD
<<<<<<< HEAD
                        raise IDNABidiError("Can not mix numeral types in a right-to-left label")
        else:
            # Bidi rule 5
            if direction not in ["L", "EN", "ES", "CS", "ET", "ON", "BN", "NSM"]:
                raise IDNABidiError("Invalid direction for codepoint at position {} in a left-to-right label".format(idx))
            # Bidi rule 6
            if direction in ["L", "EN"]:
                valid_ending = True
            elif direction != "NSM":
                valid_ending = False

    if not valid_ending:
        raise IDNABidiError("Label ends with illegal codepoint directionality")
=======
                        raise IDNABidiError('Can not mix numeral types in a right-to-left label')
=======
                        raise IDNABidiError("Can not mix numeral types in a right-to-left label")
>>>>>>> 903c694 (inital commit)
        else:
            # Bidi rule 5
            if direction not in ["L", "EN", "ES", "CS", "ET", "ON", "BN", "NSM"]:
                raise IDNABidiError("Invalid direction for codepoint at position {} in a left-to-right label".format(idx))
            # Bidi rule 6
            if direction in ["L", "EN"]:
                valid_ending = True
            elif direction != "NSM":
                valid_ending = False

    if not valid_ending:
<<<<<<< HEAD
        raise IDNABidiError('Label ends with illegal codepoint directionality')
>>>>>>> ecbd90b (Initial commit)
=======
        raise IDNABidiError("Label ends with illegal codepoint directionality")
>>>>>>> 903c694 (inital commit)

    return True


def check_initial_combiner(label: str) -> bool:
<<<<<<< HEAD
<<<<<<< HEAD
    if unicodedata.category(label[0])[0] == "M":
        raise IDNAError("Label begins with an illegal combining character")
=======
    if unicodedata.category(label[0])[0] == 'M':
        raise IDNAError('Label begins with an illegal combining character')
>>>>>>> ecbd90b (Initial commit)
=======
    if unicodedata.category(label[0])[0] == "M":
        raise IDNAError("Label begins with an illegal combining character")
>>>>>>> 903c694 (inital commit)
    return True


def check_hyphen_ok(label: str) -> bool:
<<<<<<< HEAD
<<<<<<< HEAD
=======
>>>>>>> 903c694 (inital commit)
    if label[2:4] == "--":
        raise IDNAError("Label has disallowed hyphens in 3rd and 4th position")
    if label[0] == "-" or label[-1] == "-":
        raise IDNAError("Label must not start or end with a hyphen")
<<<<<<< HEAD
=======
    if label[2:4] == '--':
        raise IDNAError('Label has disallowed hyphens in 3rd and 4th position')
    if label[0] == '-' or label[-1] == '-':
        raise IDNAError('Label must not start or end with a hyphen')
>>>>>>> ecbd90b (Initial commit)
=======
>>>>>>> 903c694 (inital commit)
    return True


def check_nfc(label: str) -> None:
<<<<<<< HEAD
<<<<<<< HEAD
    if unicodedata.normalize("NFC", label) != label:
        raise IDNAError("Label must be in Normalization Form C")
=======
    if unicodedata.normalize('NFC', label) != label:
        raise IDNAError('Label must be in Normalization Form C')
>>>>>>> ecbd90b (Initial commit)
=======
    if unicodedata.normalize("NFC", label) != label:
        raise IDNAError("Label must be in Normalization Form C")
>>>>>>> 903c694 (inital commit)


def valid_contextj(label: str, pos: int) -> bool:
    cp_value = ord(label[pos])

<<<<<<< HEAD
<<<<<<< HEAD
    if cp_value == 0x200C:
=======
    if cp_value == 0x200c:

>>>>>>> ecbd90b (Initial commit)
=======
    if cp_value == 0x200C:
>>>>>>> 903c694 (inital commit)
        if pos > 0:
            if _combining_class(ord(label[pos - 1])) == _virama_combining_class:
                return True

        ok = False
<<<<<<< HEAD
<<<<<<< HEAD
        for i in range(pos - 1, -1, -1):
            joining_type = idnadata.joining_types.get(ord(label[i]))
            if joining_type == ord("T"):
                continue
            elif joining_type in [ord("L"), ord("D")]:
                ok = True
                break
            else:
                break
=======
        for i in range(pos-1, -1, -1):
=======
        for i in range(pos - 1, -1, -1):
>>>>>>> 903c694 (inital commit)
            joining_type = idnadata.joining_types.get(ord(label[i]))
            if joining_type == ord("T"):
                continue
            elif joining_type in [ord("L"), ord("D")]:
                ok = True
                break
<<<<<<< HEAD
>>>>>>> ecbd90b (Initial commit)
=======
            else:
                break
>>>>>>> 903c694 (inital commit)

        if not ok:
            return False

        ok = False
<<<<<<< HEAD
<<<<<<< HEAD
        for i in range(pos + 1, len(label)):
            joining_type = idnadata.joining_types.get(ord(label[i]))
            if joining_type == ord("T"):
                continue
            elif joining_type in [ord("R"), ord("D")]:
                ok = True
                break
            else:
                break
        return ok

    if cp_value == 0x200D:
=======
        for i in range(pos+1, len(label)):
=======
        for i in range(pos + 1, len(label)):
>>>>>>> 903c694 (inital commit)
            joining_type = idnadata.joining_types.get(ord(label[i]))
            if joining_type == ord("T"):
                continue
            elif joining_type in [ord("R"), ord("D")]:
                ok = True
                break
            else:
                break
        return ok

<<<<<<< HEAD
    if cp_value == 0x200d:

>>>>>>> ecbd90b (Initial commit)
=======
    if cp_value == 0x200D:
>>>>>>> 903c694 (inital commit)
        if pos > 0:
            if _combining_class(ord(label[pos - 1])) == _virama_combining_class:
                return True
        return False

    else:
<<<<<<< HEAD
<<<<<<< HEAD
=======

>>>>>>> ecbd90b (Initial commit)
=======
>>>>>>> 903c694 (inital commit)
        return False


def valid_contexto(label: str, pos: int, exception: bool = False) -> bool:
    cp_value = ord(label[pos])

<<<<<<< HEAD
<<<<<<< HEAD
    if cp_value == 0x00B7:
        if 0 < pos < len(label) - 1:
            if ord(label[pos - 1]) == 0x006C and ord(label[pos + 1]) == 0x006C:
=======
    if cp_value == 0x00b7:
        if 0 < pos < len(label)-1:
            if ord(label[pos - 1]) == 0x006c and ord(label[pos + 1]) == 0x006c:
>>>>>>> ecbd90b (Initial commit)
=======
    if cp_value == 0x00B7:
        if 0 < pos < len(label) - 1:
            if ord(label[pos - 1]) == 0x006C and ord(label[pos + 1]) == 0x006C:
>>>>>>> 903c694 (inital commit)
                return True
        return False

    elif cp_value == 0x0375:
<<<<<<< HEAD
<<<<<<< HEAD
        if pos < len(label) - 1 and len(label) > 1:
            return _is_script(label[pos + 1], "Greek")
        return False

    elif cp_value == 0x05F3 or cp_value == 0x05F4:
        if pos > 0:
            return _is_script(label[pos - 1], "Hebrew")
        return False

    elif cp_value == 0x30FB:
        for cp in label:
            if cp == "\u30fb":
                continue
            if _is_script(cp, "Hiragana") or _is_script(cp, "Katakana") or _is_script(cp, "Han"):
=======
        if pos < len(label)-1 and len(label) > 1:
            return _is_script(label[pos + 1], 'Greek')
=======
        if pos < len(label) - 1 and len(label) > 1:
            return _is_script(label[pos + 1], "Greek")
>>>>>>> 903c694 (inital commit)
        return False

    elif cp_value == 0x05F3 or cp_value == 0x05F4:
        if pos > 0:
            return _is_script(label[pos - 1], "Hebrew")
        return False

    elif cp_value == 0x30FB:
        for cp in label:
            if cp == "\u30fb":
                continue
<<<<<<< HEAD
            if _is_script(cp, 'Hiragana') or _is_script(cp, 'Katakana') or _is_script(cp, 'Han'):
>>>>>>> ecbd90b (Initial commit)
=======
            if _is_script(cp, "Hiragana") or _is_script(cp, "Katakana") or _is_script(cp, "Han"):
>>>>>>> 903c694 (inital commit)
                return True
        return False

    elif 0x660 <= cp_value <= 0x669:
        for cp in label:
<<<<<<< HEAD
<<<<<<< HEAD
            if 0x6F0 <= ord(cp) <= 0x06F9:
                return False
        return True

    elif 0x6F0 <= cp_value <= 0x6F9:
=======
            if 0x6f0 <= ord(cp) <= 0x06f9:
                return False
        return True

    elif 0x6f0 <= cp_value <= 0x6f9:
>>>>>>> ecbd90b (Initial commit)
=======
            if 0x6F0 <= ord(cp) <= 0x06F9:
                return False
        return True

    elif 0x6F0 <= cp_value <= 0x6F9:
>>>>>>> 903c694 (inital commit)
        for cp in label:
            if 0x660 <= ord(cp) <= 0x0669:
                return False
        return True

    return False


def check_label(label: Union[str, bytes, bytearray]) -> None:
    if isinstance(label, (bytes, bytearray)):
<<<<<<< HEAD
<<<<<<< HEAD
        label = label.decode("utf-8")
    if len(label) == 0:
        raise IDNAError("Empty Label")
=======
        label = label.decode('utf-8')
    if len(label) == 0:
        raise IDNAError('Empty Label')
>>>>>>> ecbd90b (Initial commit)
=======
        label = label.decode("utf-8")
    if len(label) == 0:
        raise IDNAError("Empty Label")
>>>>>>> 903c694 (inital commit)

    check_nfc(label)
    check_hyphen_ok(label)
    check_initial_combiner(label)

<<<<<<< HEAD
<<<<<<< HEAD
    for pos, cp in enumerate(label):
        cp_value = ord(cp)
        if intranges_contain(cp_value, idnadata.codepoint_classes["PVALID"]):
            continue
        elif intranges_contain(cp_value, idnadata.codepoint_classes["CONTEXTJ"]):
            try:
                if not valid_contextj(label, pos):
                    raise InvalidCodepointContext(
                        "Joiner {} not allowed at position {} in {}".format(_unot(cp_value), pos + 1, repr(label))
                    )
            except ValueError:
                raise IDNAError(
                    "Unknown codepoint adjacent to joiner {} at position {} in {}".format(
                        _unot(cp_value), pos + 1, repr(label)
                    )
                )
        elif intranges_contain(cp_value, idnadata.codepoint_classes["CONTEXTO"]):
            if not valid_contexto(label, pos):
                raise InvalidCodepointContext(
                    "Codepoint {} not allowed at position {} in {}".format(_unot(cp_value), pos + 1, repr(label))
                )
        else:
            raise InvalidCodepoint(
                "Codepoint {} at position {} of {} not allowed".format(_unot(cp_value), pos + 1, repr(label))
            )
=======
    for (pos, cp) in enumerate(label):
=======
    for pos, cp in enumerate(label):
>>>>>>> 903c694 (inital commit)
        cp_value = ord(cp)
        if intranges_contain(cp_value, idnadata.codepoint_classes["PVALID"]):
            continue
        elif intranges_contain(cp_value, idnadata.codepoint_classes["CONTEXTJ"]):
            try:
                if not valid_contextj(label, pos):
                    raise InvalidCodepointContext(
                        "Joiner {} not allowed at position {} in {}".format(_unot(cp_value), pos + 1, repr(label))
                    )
            except ValueError:
                raise IDNAError(
                    "Unknown codepoint adjacent to joiner {} at position {} in {}".format(
                        _unot(cp_value), pos + 1, repr(label)
                    )
                )
        elif intranges_contain(cp_value, idnadata.codepoint_classes["CONTEXTO"]):
            if not valid_contexto(label, pos):
                raise InvalidCodepointContext(
                    "Codepoint {} not allowed at position {} in {}".format(_unot(cp_value), pos + 1, repr(label))
                )
        else:
<<<<<<< HEAD
            raise InvalidCodepoint('Codepoint {} at position {} of {} not allowed'.format(_unot(cp_value), pos+1, repr(label)))
>>>>>>> ecbd90b (Initial commit)
=======
            raise InvalidCodepoint(
                "Codepoint {} at position {} of {} not allowed".format(_unot(cp_value), pos + 1, repr(label))
            )
>>>>>>> 903c694 (inital commit)

    check_bidi(label)


def alabel(label: str) -> bytes:
    try:
<<<<<<< HEAD
<<<<<<< HEAD
        label_bytes = label.encode("ascii")
        ulabel(label_bytes)
        if not valid_label_length(label_bytes):
            raise IDNAError("Label too long")
=======
        label_bytes = label.encode('ascii')
        ulabel(label_bytes)
        if not valid_label_length(label_bytes):
            raise IDNAError('Label too long')
>>>>>>> ecbd90b (Initial commit)
=======
        label_bytes = label.encode("ascii")
        ulabel(label_bytes)
        if not valid_label_length(label_bytes):
            raise IDNAError("Label too long")
>>>>>>> 903c694 (inital commit)
        return label_bytes
    except UnicodeEncodeError:
        pass

<<<<<<< HEAD
<<<<<<< HEAD
    check_label(label)
    label_bytes = _alabel_prefix + _punycode(label)

    if not valid_label_length(label_bytes):
        raise IDNAError("Label too long")
=======
    if not label:
        raise IDNAError('No Input')

    label = str(label)
=======
>>>>>>> 903c694 (inital commit)
    check_label(label)
    label_bytes = _alabel_prefix + _punycode(label)

    if not valid_label_length(label_bytes):
<<<<<<< HEAD
        raise IDNAError('Label too long')
>>>>>>> ecbd90b (Initial commit)
=======
        raise IDNAError("Label too long")
>>>>>>> 903c694 (inital commit)

    return label_bytes


def ulabel(label: Union[str, bytes, bytearray]) -> str:
    if not isinstance(label, (bytes, bytearray)):
        try:
<<<<<<< HEAD
<<<<<<< HEAD
            label_bytes = label.encode("ascii")
=======
            label_bytes = label.encode('ascii')
>>>>>>> ecbd90b (Initial commit)
=======
            label_bytes = label.encode("ascii")
>>>>>>> 903c694 (inital commit)
        except UnicodeEncodeError:
            check_label(label)
            return label
    else:
        label_bytes = label

    label_bytes = label_bytes.lower()
    if label_bytes.startswith(_alabel_prefix):
<<<<<<< HEAD
<<<<<<< HEAD
        label_bytes = label_bytes[len(_alabel_prefix) :]
        if not label_bytes:
            raise IDNAError("Malformed A-label, no Punycode eligible content found")
        if label_bytes.decode("ascii")[-1] == "-":
            raise IDNAError("A-label must not end with a hyphen")
    else:
        check_label(label_bytes)
        return label_bytes.decode("ascii")

    try:
        label = label_bytes.decode("punycode")
    except UnicodeError:
        raise IDNAError("Invalid A-label")
=======
        label_bytes = label_bytes[len(_alabel_prefix):]
=======
        label_bytes = label_bytes[len(_alabel_prefix) :]
>>>>>>> 903c694 (inital commit)
        if not label_bytes:
            raise IDNAError("Malformed A-label, no Punycode eligible content found")
        if label_bytes.decode("ascii")[-1] == "-":
            raise IDNAError("A-label must not end with a hyphen")
    else:
        check_label(label_bytes)
        return label_bytes.decode("ascii")

    try:
        label = label_bytes.decode("punycode")
    except UnicodeError:
<<<<<<< HEAD
        raise IDNAError('Invalid A-label')
>>>>>>> ecbd90b (Initial commit)
=======
        raise IDNAError("Invalid A-label")
>>>>>>> 903c694 (inital commit)
    check_label(label)
    return label


def uts46_remap(domain: str, std3_rules: bool = True, transitional: bool = False) -> str:
    """Re-map the characters in the string according to UTS46 processing."""
    from .uts46data import uts46data
<<<<<<< HEAD
<<<<<<< HEAD

    output = ""
=======
    output = ''
>>>>>>> ecbd90b (Initial commit)
=======

    output = ""
>>>>>>> 903c694 (inital commit)

    for pos, char in enumerate(domain):
        code_point = ord(char)
        try:
<<<<<<< HEAD
<<<<<<< HEAD
            uts46row = uts46data[code_point if code_point < 256 else bisect.bisect_left(uts46data, (code_point, "Z")) - 1]
            status = uts46row[1]
            replacement: Optional[str] = None
            if len(uts46row) == 3:
                replacement = uts46row[2]
            if (
                status == "V"
                or (status == "D" and not transitional)
                or (status == "3" and not std3_rules and replacement is None)
            ):
                output += char
            elif replacement is not None and (
                status == "M" or (status == "3" and not std3_rules) or (status == "D" and transitional)
            ):
                output += replacement
            elif status != "I":
                raise IndexError()
        except IndexError:
            raise InvalidCodepoint(
                "Codepoint {} not allowed at position {} in {}".format(_unot(code_point), pos + 1, repr(domain))
            )

    return unicodedata.normalize("NFC", output)


def encode(
    s: Union[str, bytes, bytearray],
    strict: bool = False,
    uts46: bool = False,
    std3_rules: bool = False,
    transitional: bool = False,
) -> bytes:
    if not isinstance(s, str):
        try:
            s = str(s, "ascii")
        except UnicodeDecodeError:
            raise IDNAError("should pass a unicode string to the function rather than a byte string.")
=======
            uts46row = uts46data[code_point if code_point < 256 else
                bisect.bisect_left(uts46data, (code_point, 'Z')) - 1]
=======
            uts46row = uts46data[code_point if code_point < 256 else bisect.bisect_left(uts46data, (code_point, "Z")) - 1]
>>>>>>> 903c694 (inital commit)
            status = uts46row[1]
            replacement: Optional[str] = None
            if len(uts46row) == 3:
                replacement = uts46row[2]
            if (
                status == "V"
                or (status == "D" and not transitional)
                or (status == "3" and not std3_rules and replacement is None)
            ):
                output += char
            elif replacement is not None and (
                status == "M" or (status == "3" and not std3_rules) or (status == "D" and transitional)
            ):
                output += replacement
            elif status != "I":
                raise IndexError()
        except IndexError:
            raise InvalidCodepoint(
                "Codepoint {} not allowed at position {} in {}".format(_unot(code_point), pos + 1, repr(domain))
            )

    return unicodedata.normalize("NFC", output)


def encode(
    s: Union[str, bytes, bytearray],
    strict: bool = False,
    uts46: bool = False,
    std3_rules: bool = False,
    transitional: bool = False,
) -> bytes:
    if not isinstance(s, str):
        try:
            s = str(s, "ascii")
        except UnicodeDecodeError:
<<<<<<< HEAD
            raise IDNAError('should pass a unicode string to the function rather than a byte string.')
>>>>>>> ecbd90b (Initial commit)
=======
            raise IDNAError("should pass a unicode string to the function rather than a byte string.")
>>>>>>> 903c694 (inital commit)
    if uts46:
        s = uts46_remap(s, std3_rules, transitional)
    trailing_dot = False
    result = []
    if strict:
<<<<<<< HEAD
<<<<<<< HEAD
        labels = s.split(".")
    else:
        labels = _unicode_dots_re.split(s)
    if not labels or labels == [""]:
        raise IDNAError("Empty domain")
    if labels[-1] == "":
=======
        labels = s.split('.')
    else:
        labels = _unicode_dots_re.split(s)
    if not labels or labels == ['']:
        raise IDNAError('Empty domain')
    if labels[-1] == '':
>>>>>>> ecbd90b (Initial commit)
=======
        labels = s.split(".")
    else:
        labels = _unicode_dots_re.split(s)
    if not labels or labels == [""]:
        raise IDNAError("Empty domain")
    if labels[-1] == "":
>>>>>>> 903c694 (inital commit)
        del labels[-1]
        trailing_dot = True
    for label in labels:
        s = alabel(label)
        if s:
            result.append(s)
        else:
<<<<<<< HEAD
<<<<<<< HEAD
            raise IDNAError("Empty label")
    if trailing_dot:
        result.append(b"")
    s = b".".join(result)
    if not valid_string_length(s, trailing_dot):
        raise IDNAError("Domain too long")
    return s


def decode(
    s: Union[str, bytes, bytearray],
    strict: bool = False,
    uts46: bool = False,
    std3_rules: bool = False,
) -> str:
    try:
        if not isinstance(s, str):
            s = str(s, "ascii")
    except UnicodeDecodeError:
        raise IDNAError("Invalid ASCII in A-label")
=======
            raise IDNAError('Empty label')
=======
            raise IDNAError("Empty label")
>>>>>>> 903c694 (inital commit)
    if trailing_dot:
        result.append(b"")
    s = b".".join(result)
    if not valid_string_length(s, trailing_dot):
        raise IDNAError("Domain too long")
    return s


def decode(
    s: Union[str, bytes, bytearray],
    strict: bool = False,
    uts46: bool = False,
    std3_rules: bool = False,
) -> str:
    try:
        if not isinstance(s, str):
            s = str(s, "ascii")
    except UnicodeDecodeError:
<<<<<<< HEAD
        raise IDNAError('Invalid ASCII in A-label')
>>>>>>> ecbd90b (Initial commit)
=======
        raise IDNAError("Invalid ASCII in A-label")
>>>>>>> 903c694 (inital commit)
    if uts46:
        s = uts46_remap(s, std3_rules, False)
    trailing_dot = False
    result = []
    if not strict:
        labels = _unicode_dots_re.split(s)
    else:
<<<<<<< HEAD
<<<<<<< HEAD
        labels = s.split(".")
    if not labels or labels == [""]:
        raise IDNAError("Empty domain")
=======
        labels = s.split('.')
    if not labels or labels == ['']:
        raise IDNAError('Empty domain')
>>>>>>> ecbd90b (Initial commit)
=======
        labels = s.split(".")
    if not labels or labels == [""]:
        raise IDNAError("Empty domain")
>>>>>>> 903c694 (inital commit)
    if not labels[-1]:
        del labels[-1]
        trailing_dot = True
    for label in labels:
        s = ulabel(label)
        if s:
            result.append(s)
        else:
<<<<<<< HEAD
<<<<<<< HEAD
            raise IDNAError("Empty label")
    if trailing_dot:
        result.append("")
    return ".".join(result)
=======
            raise IDNAError('Empty label')
    if trailing_dot:
        result.append('')
    return '.'.join(result)
>>>>>>> ecbd90b (Initial commit)
=======
            raise IDNAError("Empty label")
    if trailing_dot:
        result.append("")
    return ".".join(result)
>>>>>>> 903c694 (inital commit)
