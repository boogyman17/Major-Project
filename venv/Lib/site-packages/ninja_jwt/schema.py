<<<<<<< HEAD
<<<<<<< HEAD
import warnings
from typing import Any, Callable, Dict, Optional, Type, cast
=======
import typing
import warnings
from typing import Any, Dict, Optional, Type, Union, cast
>>>>>>> ecbd90b (Initial commit)
=======
import warnings
from typing import Any, Callable, Dict, Optional, Type, cast
>>>>>>> 903c694 (inital commit)

from django.conf import settings
from django.contrib.auth import authenticate, get_user_model
from django.contrib.auth.models import AbstractUser, update_last_login
<<<<<<< HEAD
<<<<<<< HEAD
from django.utils.translation import gettext_lazy as _
from ninja import ModelSchema, Schema
from pydantic import root_validator
=======
from django.http import HttpRequest
from django.utils.translation import gettext_lazy as _
from ninja import ModelSchema, Schema
from ninja.schema import DjangoGetter
from ninja_extra import service_resolver
from ninja_extra.context import RouteContext
from pydantic import ConfigDict, model_validator
>>>>>>> ecbd90b (Initial commit)
=======
from django.utils.translation import gettext_lazy as _
from ninja import ModelSchema, Schema
from pydantic import root_validator
>>>>>>> 903c694 (inital commit)

import ninja_jwt.exceptions as exceptions
from ninja_jwt.utils import token_error

from .settings import api_settings
from .tokens import RefreshToken, SlidingToken, UntypedToken

if api_settings.BLACKLIST_AFTER_ROTATION:
    from .token_blacklist.models import BlacklistedToken

user_name_field = get_user_model().USERNAME_FIELD  # type: ignore

<<<<<<< HEAD
<<<<<<< HEAD
=======
SCHEMA_INPUT = Union[DjangoGetter, Dict]


class SchemaInputService:
    def __init__(self, values: SCHEMA_INPUT, model_config: ConfigDict) -> None:
        self.model_config = model_config
        self.values = values

    def get_request(self) -> HttpRequest:
        if self.model_config.get("extra") == "forbid":
            return service_resolver(RouteContext).request
        return self.values._context.get("request")

    def get_values(self) -> Dict:
        if self.model_config.get("extra") == "forbid":
            return self.values
        if isinstance(self.values, DjangoGetter):
            return self.values._obj
        return self.values

>>>>>>> ecbd90b (Initial commit)
=======
>>>>>>> 903c694 (inital commit)

class AuthUserSchema(ModelSchema):
    class Config:
        model = get_user_model()
        model_fields = [user_name_field]


class InputSchemaMixin:
<<<<<<< HEAD
<<<<<<< HEAD
    dict: Callable

=======
>>>>>>> ecbd90b (Initial commit)
=======
    dict: Callable

>>>>>>> 903c694 (inital commit)
    @classmethod
    def get_response_schema(cls) -> Type[Schema]:
        raise NotImplementedError("Must implement `get_response_schema`")

    def to_response_schema(self):
        _schema_type = self.get_response_schema()
<<<<<<< HEAD
<<<<<<< HEAD
        return _schema_type(**self.dict())
=======
        return _schema_type(**self.model_dump())
>>>>>>> ecbd90b (Initial commit)
=======
        return _schema_type(**self.dict())
>>>>>>> 903c694 (inital commit)


class TokenInputSchemaMixin(InputSchemaMixin):
    _user: Optional[AbstractUser] = None

    _default_error_messages = {
        "no_active_account": _("No active account found with the given credentials")
    }

    def check_user_authentication_rule(self) -> None:
        if not api_settings.USER_AUTHENTICATION_RULE(self._user):
            raise exceptions.AuthenticationFailed(
                self._default_error_messages["no_active_account"]
            )

    @classmethod
<<<<<<< HEAD
<<<<<<< HEAD
    def validate_values(cls, values: Dict) -> dict:
=======
    def validate_values(cls, request: HttpRequest, values: Dict) -> Dict:
>>>>>>> ecbd90b (Initial commit)
=======
    def validate_values(cls, values: Dict) -> dict:
>>>>>>> 903c694 (inital commit)
        if user_name_field not in values and "password" not in values:
            raise exceptions.ValidationError(
                {
                    user_name_field: f"{user_name_field} is required",
                    "password": "password is required",
                }
            )

        if not values.get(user_name_field):
            raise exceptions.ValidationError(
                {user_name_field: f"{user_name_field} is required"}
            )

        if not values.get("password"):
            raise exceptions.ValidationError({"password": "password is required"})

<<<<<<< HEAD
<<<<<<< HEAD
        _user = authenticate(**values)
=======
        _user = authenticate(request, **values)
>>>>>>> ecbd90b (Initial commit)
=======
        _user = authenticate(**values)
>>>>>>> 903c694 (inital commit)
        cls._user = _user

        if not (_user is not None and _user.is_active):
            raise exceptions.AuthenticationFailed(
                cls._default_error_messages["no_active_account"]
            )

        return values

    def output_schema(self) -> Schema:
        warnings.warn(
<<<<<<< HEAD
<<<<<<< HEAD
            "output_schema() is deprecated in favor of " "to_response_schema()",
=======
            "output_schema() is deprecated in favor of to_response_schema()",
>>>>>>> ecbd90b (Initial commit)
=======
            "output_schema() is deprecated in favor of " "to_response_schema()",
>>>>>>> 903c694 (inital commit)
            DeprecationWarning,
            stacklevel=2,
        )
        return self.to_response_schema()

    @classmethod
    def get_token(cls, user: AbstractUser) -> Dict:
        raise NotImplementedError(
            "Must implement `get_token` method for `TokenObtainSerializer` subclasses"
        )


class TokenObtainInputSchemaBase(ModelSchema, TokenInputSchemaMixin):
    class Config:
<<<<<<< HEAD
<<<<<<< HEAD
        model = get_user_model()
        model_fields = ["password", user_name_field]

    @root_validator(pre=True)
    def validate_inputs(cls, values: Dict) -> dict:
        return cls.validate_values(values)

    @root_validator
=======
        # extra = "allow"
=======
>>>>>>> 903c694 (inital commit)
        model = get_user_model()
        model_fields = ["password", user_name_field]

    @root_validator(pre=True)
    def validate_inputs(cls, values: Dict) -> dict:
        return cls.validate_values(values)

<<<<<<< HEAD
        if isinstance(input_values, dict):
            values.update(cls.validate_values(request=request, values=input_values))
            return values
        return values

    @model_validator(mode="after")
>>>>>>> ecbd90b (Initial commit)
=======
    @root_validator
>>>>>>> 903c694 (inital commit)
    def post_validate(cls, values: Dict) -> dict:
        return cls.post_validate_schema(values)

    @classmethod
    def post_validate_schema(cls, values: Dict) -> dict:
        """
        This is a post validate process which is common for any token generating schema.
        :param values:
        :return:
        """
        # get_token can return values that wants to apply to `OutputSchema`

        data = cls.get_token(cls._user)

        if not isinstance(data, dict):
            raise Exception("`get_token` must return a `typing.Dict` type.")

<<<<<<< HEAD
<<<<<<< HEAD
        values.update(data)
=======
        # a workaround for extra attributes since adding extra=allow in modelconfig adds `addition_props`
        # field to the schema
        values.__dict__.update(token_data=data)
>>>>>>> ecbd90b (Initial commit)
=======
        values.update(data)
>>>>>>> 903c694 (inital commit)

        if api_settings.UPDATE_LAST_LOGIN:
            update_last_login(None, cls._user)

        return values

<<<<<<< HEAD
<<<<<<< HEAD
    def to_response_schema(self):
        _schema_type = self.get_response_schema()
        return _schema_type(**self.dict(exclude={"password"}))
=======
    def get_response_schema_init_kwargs(self) -> dict:
        return dict(
            self.dict(exclude={"password"}), **self.__dict__.get("token_data", {})
        )

    def to_response_schema(self):
        _schema_type = self.get_response_schema()
        return _schema_type(**self.get_response_schema_init_kwargs())
>>>>>>> ecbd90b (Initial commit)
=======
    def to_response_schema(self):
        _schema_type = self.get_response_schema()
        return _schema_type(**self.dict(exclude={"password"}))
>>>>>>> 903c694 (inital commit)


class TokenObtainPairOutputSchema(AuthUserSchema):
    refresh: str
    access: str


class TokenObtainPairInputSchema(TokenObtainInputSchemaBase):
    @classmethod
    def get_response_schema(cls) -> Type[Schema]:
        return TokenObtainPairOutputSchema

    @classmethod
    def get_token(cls, user: AbstractUser) -> Dict:
        values = {}
        refresh = RefreshToken.for_user(user)
        refresh = cast(RefreshToken, refresh)
        values["refresh"] = str(refresh)
        values["access"] = str(refresh.access_token)
        return values


class TokenObtainSlidingOutputSchema(AuthUserSchema):
    token: str


class TokenObtainSlidingInputSchema(TokenObtainInputSchemaBase):
    @classmethod
    def get_response_schema(cls) -> Type:
        return TokenObtainSlidingOutputSchema

    @classmethod
    def get_token(cls, user: AbstractUser) -> Dict:
        values = {}
        slide_token = SlidingToken.for_user(user)
        values["token"] = str(slide_token)
        return values


class TokenRefreshInputSchema(Schema, InputSchemaMixin):
    refresh: str

<<<<<<< HEAD
<<<<<<< HEAD
=======
>>>>>>> 903c694 (inital commit)
    @root_validator
    def validate_schema(cls, values: Dict) -> dict:
        if not values.get("refresh"):
            raise exceptions.ValidationError({"refresh": "token is required"})
<<<<<<< HEAD
=======
    @model_validator(mode="before")
    def validate_schema(cls, values: SCHEMA_INPUT) -> dict:
        schema_input = SchemaInputService(values, cls.model_config)
        values = schema_input.get_values()

        if isinstance(values, dict):
            if not values.get("refresh"):
                raise exceptions.ValidationError({"refresh": "token is required"})
>>>>>>> ecbd90b (Initial commit)
=======
>>>>>>> 903c694 (inital commit)
        return values

    @classmethod
    def get_response_schema(cls) -> Type[Schema]:
        return TokenRefreshOutputSchema


class TokenRefreshOutputSchema(Schema):
    refresh: str
    access: Optional[str]

<<<<<<< HEAD
<<<<<<< HEAD
    @root_validator
    @token_error
    def validate_schema(cls, values: Dict) -> dict:
        if not values.get("refresh"):
            raise exceptions.ValidationError({"refresh": "refresh token is required"})

        refresh = RefreshToken(values["refresh"])

        data = {"access": str(refresh.access_token)}

        if api_settings.ROTATE_REFRESH_TOKENS:
            if api_settings.BLACKLIST_AFTER_ROTATION:
                try:
                    # Attempt to blacklist the given refresh token
                    refresh.blacklist()
                except AttributeError:
                    # If blacklist app not installed, `blacklist` method will
                    # not be present
                    pass

            refresh.set_jti()
            refresh.set_exp()
            refresh.set_iat()

            data["refresh"] = str(refresh)
        values.update(data)
=======
    @model_validator(mode="before")
=======
    @root_validator
>>>>>>> 903c694 (inital commit)
    @token_error
    def validate_schema(cls, values: Dict) -> dict:
        if not values.get("refresh"):
            raise exceptions.ValidationError({"refresh": "refresh token is required"})

        refresh = RefreshToken(values["refresh"])

        data = {"access": str(refresh.access_token)}

        if api_settings.ROTATE_REFRESH_TOKENS:
            if api_settings.BLACKLIST_AFTER_ROTATION:
                try:
                    # Attempt to blacklist the given refresh token
                    refresh.blacklist()
                except AttributeError:
                    # If blacklist app not installed, `blacklist` method will
                    # not be present
                    pass

            refresh.set_jti()
            refresh.set_exp()
            refresh.set_iat()

<<<<<<< HEAD
                refresh.set_jti()
                refresh.set_exp()
                refresh.set_iat()

                data["refresh"] = str(refresh)
            values.update(data)
>>>>>>> ecbd90b (Initial commit)
=======
            data["refresh"] = str(refresh)
        values.update(data)
>>>>>>> 903c694 (inital commit)
        return values


class TokenRefreshSlidingInputSchema(Schema, InputSchemaMixin):
    token: str

<<<<<<< HEAD
<<<<<<< HEAD
=======
>>>>>>> 903c694 (inital commit)
    @root_validator
    def validate_schema(cls, values: Dict) -> dict:
        if not values.get("token"):
            raise exceptions.ValidationError({"token": "token is required"})
<<<<<<< HEAD
=======
    @model_validator(mode="before")
    def validate_schema(cls, values: SCHEMA_INPUT) -> dict:
        schema_input = SchemaInputService(values, cls.model_config)
        values = schema_input.get_values()

        if isinstance(values, dict):
            if not values.get("token"):
                raise exceptions.ValidationError({"token": "token is required"})
>>>>>>> ecbd90b (Initial commit)
=======
>>>>>>> 903c694 (inital commit)
        return values

    @classmethod
    def get_response_schema(cls) -> Type[Schema]:
        return TokenRefreshSlidingOutputSchema


class TokenRefreshSlidingOutputSchema(Schema):
    token: str

<<<<<<< HEAD
<<<<<<< HEAD
    @root_validator
    @token_error
    def validate_schema(cls, values: Dict) -> dict:
        if not values.get("token"):
            raise exceptions.ValidationError({"token": "token is required"})

        token = SlidingToken(values["token"])

        # Check that the timestamp in the "refresh_exp" claim has not
        # passed
        token.check_exp(api_settings.SLIDING_TOKEN_REFRESH_EXP_CLAIM)

        # Update the "exp" and "iat" claims
        token.set_exp()
        token.set_iat()
        values.update({"token": str(token)})
=======
    @model_validator(mode="before")
=======
    @root_validator
>>>>>>> 903c694 (inital commit)
    @token_error
    def validate_schema(cls, values: Dict) -> dict:
        if not values.get("token"):
            raise exceptions.ValidationError({"token": "token is required"})

        token = SlidingToken(values["token"])

        # Check that the timestamp in the "refresh_exp" claim has not
        # passed
        token.check_exp(api_settings.SLIDING_TOKEN_REFRESH_EXP_CLAIM)

<<<<<<< HEAD
            # Check that the timestamp in the "refresh_exp" claim has not
            # passed
            token.check_exp(api_settings.SLIDING_TOKEN_REFRESH_EXP_CLAIM)

            # Update the "exp" and "iat" claims
            token.set_exp()
            token.set_iat()
            values.update({"token": str(token)})
>>>>>>> ecbd90b (Initial commit)
=======
        # Update the "exp" and "iat" claims
        token.set_exp()
        token.set_iat()
        values.update({"token": str(token)})
>>>>>>> 903c694 (inital commit)
        return values


class TokenVerifyInputSchema(Schema, InputSchemaMixin):
    token: str

<<<<<<< HEAD
<<<<<<< HEAD
    @root_validator
    @token_error
    def validate_schema(cls, values: Dict) -> dict:
        if not values.get("token"):
            raise exceptions.ValidationError({"token": "token is required"})
        token = UntypedToken(values["token"])

        if (
            api_settings.BLACKLIST_AFTER_ROTATION
            and "ninja_jwt.token_blacklist" in settings.INSTALLED_APPS
        ):
            jti = token.get(api_settings.JTI_CLAIM)
            if BlacklistedToken.objects.filter(token__jti=jti).exists():
                raise exceptions.ValidationError("Token is blacklisted")
=======
    @model_validator(mode="before")
=======
    @root_validator
>>>>>>> 903c694 (inital commit)
    @token_error
    def validate_schema(cls, values: Dict) -> dict:
        if not values.get("token"):
            raise exceptions.ValidationError({"token": "token is required"})
        token = UntypedToken(values["token"])

<<<<<<< HEAD
        if isinstance(values, dict):
            if not values.get("token"):
                raise exceptions.ValidationError({"token": "token is required"})
            token = UntypedToken(values["token"])

            if (
                api_settings.BLACKLIST_AFTER_ROTATION
                and "ninja_jwt.token_blacklist" in settings.INSTALLED_APPS
            ):
                jti = token.get(api_settings.JTI_CLAIM)
                if BlacklistedToken.objects.filter(token__jti=jti).exists():
                    raise exceptions.ValidationError("Token is blacklisted")
>>>>>>> ecbd90b (Initial commit)
=======
        if (
            api_settings.BLACKLIST_AFTER_ROTATION
            and "ninja_jwt.token_blacklist" in settings.INSTALLED_APPS
        ):
            jti = token.get(api_settings.JTI_CLAIM)
            if BlacklistedToken.objects.filter(token__jti=jti).exists():
                raise exceptions.ValidationError("Token is blacklisted")
>>>>>>> 903c694 (inital commit)

        return values

    @classmethod
    def get_response_schema(cls) -> Type[Schema]:
        return Schema

    def to_response_schema(self):
        return {}


class TokenBlacklistInputSchema(Schema, InputSchemaMixin):
    refresh: str

<<<<<<< HEAD
<<<<<<< HEAD
    @root_validator
    @token_error
    def validate_schema(cls, values: Dict) -> dict:
        if not values.get("refresh"):
            raise exceptions.ValidationError({"refresh": "refresh token is required"})
        refresh = RefreshToken(values["refresh"])
        try:
            refresh.blacklist()
        except AttributeError:
            pass
=======
    @model_validator(mode="before")
    @token_error
    def validate_schema(cls, values: DjangoGetter) -> dict:
        schema_input = SchemaInputService(values, cls.model_config)
        values = schema_input.get_values()

        if isinstance(values, dict):
            if not values.get("refresh"):
                raise exceptions.ValidationError(
                    {"refresh": "refresh token is required"}
                )
            refresh = RefreshToken(values["refresh"])
            try:
                refresh.blacklist()
            except AttributeError:
                pass
>>>>>>> ecbd90b (Initial commit)
=======
    @root_validator
    @token_error
    def validate_schema(cls, values: Dict) -> dict:
        if not values.get("refresh"):
            raise exceptions.ValidationError({"refresh": "refresh token is required"})
        refresh = RefreshToken(values["refresh"])
        try:
            refresh.blacklist()
        except AttributeError:
            pass
>>>>>>> 903c694 (inital commit)
        return values

    @classmethod
    def get_response_schema(cls) -> Type[Schema]:
        return Schema

    def to_response_schema(self):
        return {}


__deprecated__ = {
    "TokenBlacklistSerializer": TokenBlacklistInputSchema,
    "TokenVerifySerializer": TokenVerifyInputSchema,
    "TokenRefreshSlidingSerializer": TokenRefreshSlidingOutputSchema,
    "TokenRefreshSlidingSchema": TokenRefreshSlidingInputSchema,
    "TokenRefreshSerializer": TokenRefreshOutputSchema,
    "TokenRefreshSchema": TokenRefreshInputSchema,
    "TokenObtainSlidingOutput": TokenObtainSlidingOutputSchema,
    "TokenObtainSerializer": TokenObtainInputSchemaBase,
    "TokenObtainPairOutput": TokenObtainPairOutputSchema,
    "TokenObtainPairSerializer": TokenObtainPairInputSchema,
    "TokenObtainSlidingSerializer": TokenObtainSlidingInputSchema,
}


def __getattr__(name: str) -> Any:  # pragma: no cover
    if name in __deprecated__:
        value = __deprecated__[name]
        warnings.warn(
            f"'{name}' is deprecated. Use '{value.__name__}' instead.",
            category=DeprecationWarning,
            stacklevel=2,
        )
        return value
    raise AttributeError(f"module '{__name__}' has no attribute '{name}'")
