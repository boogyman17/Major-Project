import base64
import binascii
import re
<<<<<<< HEAD
<<<<<<< HEAD
from typing import Union
=======
from typing import Optional, Union
>>>>>>> ecbd90b (Initial commit)
=======
from typing import Union
>>>>>>> 903c694 (inital commit)

try:
    from cryptography.hazmat.primitives.asymmetric.ec import EllipticCurve
    from cryptography.hazmat.primitives.asymmetric.utils import (
        decode_dss_signature,
        encode_dss_signature,
    )
except ModuleNotFoundError:
<<<<<<< HEAD
<<<<<<< HEAD
    EllipticCurve = None


def force_bytes(value: Union[str, bytes]) -> bytes:
=======
    pass


def force_bytes(value: Union[bytes, str]) -> bytes:
>>>>>>> ecbd90b (Initial commit)
=======
    EllipticCurve = None


def force_bytes(value: Union[str, bytes]) -> bytes:
>>>>>>> 903c694 (inital commit)
    if isinstance(value, str):
        return value.encode("utf-8")
    elif isinstance(value, bytes):
        return value
    else:
        raise TypeError("Expected a string value")


<<<<<<< HEAD
<<<<<<< HEAD
def base64url_decode(input: Union[str, bytes]) -> bytes:
    if isinstance(input, str):
        input = input.encode("ascii")

    rem = len(input) % 4

    if rem > 0:
        input += b"=" * (4 - rem)

    return base64.urlsafe_b64decode(input)
=======
def base64url_decode(input: Union[bytes, str]) -> bytes:
    input_bytes = force_bytes(input)
=======
def base64url_decode(input: Union[str, bytes]) -> bytes:
    if isinstance(input, str):
        input = input.encode("ascii")
>>>>>>> 903c694 (inital commit)

    rem = len(input) % 4

    if rem > 0:
        input += b"=" * (4 - rem)

<<<<<<< HEAD
    return base64.urlsafe_b64decode(input_bytes)
>>>>>>> ecbd90b (Initial commit)
=======
    return base64.urlsafe_b64decode(input)
>>>>>>> 903c694 (inital commit)


def base64url_encode(input: bytes) -> bytes:
    return base64.urlsafe_b64encode(input).replace(b"=", b"")


<<<<<<< HEAD
<<<<<<< HEAD
def to_base64url_uint(val: int) -> bytes:
    if val < 0:
        raise ValueError("Must be a positive integer")

    int_bytes = bytes_from_int(val)
=======
def to_base64url_uint(val: int, *, bit_length: Optional[int] = None) -> bytes:
    if val < 0:
        raise ValueError("Must be a positive integer")

    int_bytes = bytes_from_int(val, bit_length=bit_length)
>>>>>>> ecbd90b (Initial commit)
=======
def to_base64url_uint(val: int) -> bytes:
    if val < 0:
        raise ValueError("Must be a positive integer")

    int_bytes = bytes_from_int(val)
>>>>>>> 903c694 (inital commit)

    if len(int_bytes) == 0:
        int_bytes = b"\x00"

    return base64url_encode(int_bytes)


<<<<<<< HEAD
<<<<<<< HEAD
=======
>>>>>>> 903c694 (inital commit)
def from_base64url_uint(val: Union[str, bytes]) -> int:
    if isinstance(val, str):
        val = val.encode("ascii")

    data = base64url_decode(val)
<<<<<<< HEAD
=======
def from_base64url_uint(val: Union[bytes, str]) -> int:
    data = base64url_decode(force_bytes(val))
>>>>>>> ecbd90b (Initial commit)
=======
>>>>>>> 903c694 (inital commit)
    return int.from_bytes(data, byteorder="big")


def number_to_bytes(num: int, num_bytes: int) -> bytes:
    padded_hex = "%0*x" % (2 * num_bytes, num)
    return binascii.a2b_hex(padded_hex.encode("ascii"))


def bytes_to_number(string: bytes) -> int:
    return int(binascii.b2a_hex(string), 16)


<<<<<<< HEAD
<<<<<<< HEAD
=======
>>>>>>> 903c694 (inital commit)
def bytes_from_int(val: int) -> bytes:
    remaining = val
    byte_length = 0

    while remaining != 0:
        remaining >>= 8
        byte_length += 1
<<<<<<< HEAD
=======
def bytes_from_int(val: int, *, bit_length: Optional[int] = None) -> bytes:
    if bit_length is None:
        bit_length = val.bit_length()
    byte_length = (bit_length + 7) // 8
>>>>>>> ecbd90b (Initial commit)
=======
>>>>>>> 903c694 (inital commit)

    return val.to_bytes(byte_length, "big", signed=False)


<<<<<<< HEAD
<<<<<<< HEAD
def der_to_raw_signature(der_sig: bytes, curve: EllipticCurve) -> bytes:
=======
def der_to_raw_signature(der_sig: bytes, curve: "EllipticCurve") -> bytes:
>>>>>>> ecbd90b (Initial commit)
=======
def der_to_raw_signature(der_sig: bytes, curve: EllipticCurve) -> bytes:
>>>>>>> 903c694 (inital commit)
    num_bits = curve.key_size
    num_bytes = (num_bits + 7) // 8

    r, s = decode_dss_signature(der_sig)

    return number_to_bytes(r, num_bytes) + number_to_bytes(s, num_bytes)


<<<<<<< HEAD
<<<<<<< HEAD
def raw_to_der_signature(raw_sig: bytes, curve: EllipticCurve) -> bytes:
=======
def raw_to_der_signature(raw_sig: bytes, curve: "EllipticCurve") -> bytes:
>>>>>>> ecbd90b (Initial commit)
=======
def raw_to_der_signature(raw_sig: bytes, curve: EllipticCurve) -> bytes:
>>>>>>> 903c694 (inital commit)
    num_bits = curve.key_size
    num_bytes = (num_bits + 7) // 8

    if len(raw_sig) != 2 * num_bytes:
        raise ValueError("Invalid signature")

    r = bytes_to_number(raw_sig[:num_bytes])
    s = bytes_to_number(raw_sig[num_bytes:])

<<<<<<< HEAD
<<<<<<< HEAD
    return encode_dss_signature(r, s)
=======
    return bytes(encode_dss_signature(r, s))
>>>>>>> ecbd90b (Initial commit)
=======
    return encode_dss_signature(r, s)
>>>>>>> 903c694 (inital commit)


# Based on https://github.com/hynek/pem/blob/7ad94db26b0bc21d10953f5dbad3acfdfacf57aa/src/pem/_core.py#L224-L252
_PEMS = {
    b"CERTIFICATE",
    b"TRUSTED CERTIFICATE",
    b"PRIVATE KEY",
    b"PUBLIC KEY",
    b"ENCRYPTED PRIVATE KEY",
    b"OPENSSH PRIVATE KEY",
    b"DSA PRIVATE KEY",
    b"RSA PRIVATE KEY",
    b"RSA PUBLIC KEY",
    b"EC PRIVATE KEY",
    b"DH PARAMETERS",
    b"NEW CERTIFICATE REQUEST",
    b"CERTIFICATE REQUEST",
    b"SSH2 PUBLIC KEY",
    b"SSH2 ENCRYPTED PRIVATE KEY",
    b"X509 CRL",
}

_PEM_RE = re.compile(
    b"----[- ]BEGIN ("
    + b"|".join(_PEMS)
    + b""")[- ]----\r?
.+?\r?
----[- ]END \\1[- ]----\r?\n?""",
    re.DOTALL,
)


def is_pem_format(key: bytes) -> bool:
    return bool(_PEM_RE.search(key))


# Based on https://github.com/pyca/cryptography/blob/bcb70852d577b3f490f015378c75cba74986297b/src/cryptography/hazmat/primitives/serialization/ssh.py#L40-L46
<<<<<<< HEAD
<<<<<<< HEAD
_CERT_SUFFIX = b"-cert-v01@openssh.com"
_SSH_PUBKEY_RC = re.compile(rb"\A(\S+)[ \t]+(\S+)")
_SSH_KEY_FORMATS = [
=======
_SSH_KEY_FORMATS = (
>>>>>>> ecbd90b (Initial commit)
=======
_CERT_SUFFIX = b"-cert-v01@openssh.com"
_SSH_PUBKEY_RC = re.compile(rb"\A(\S+)[ \t]+(\S+)")
_SSH_KEY_FORMATS = [
>>>>>>> 903c694 (inital commit)
    b"ssh-ed25519",
    b"ssh-rsa",
    b"ssh-dss",
    b"ecdsa-sha2-nistp256",
    b"ecdsa-sha2-nistp384",
    b"ecdsa-sha2-nistp521",
<<<<<<< HEAD
<<<<<<< HEAD
]


def is_ssh_key(key: bytes) -> bool:
    if any(string_value in key for string_value in _SSH_KEY_FORMATS):
        return True

    ssh_pubkey_match = _SSH_PUBKEY_RC.match(key)
    if ssh_pubkey_match:
        key_type = ssh_pubkey_match.group(1)
        if _CERT_SUFFIX == key_type[-len(_CERT_SUFFIX) :]:
            return True

    return False
=======
)


def is_ssh_key(key: bytes) -> bool:
    return key.startswith(_SSH_KEY_FORMATS)
>>>>>>> ecbd90b (Initial commit)
=======
]


def is_ssh_key(key: bytes) -> bool:
    if any(string_value in key for string_value in _SSH_KEY_FORMATS):
        return True

    ssh_pubkey_match = _SSH_PUBKEY_RC.match(key)
    if ssh_pubkey_match:
        key_type = ssh_pubkey_match.group(1)
        if _CERT_SUFFIX == key_type[-len(_CERT_SUFFIX) :]:
            return True

    return False
>>>>>>> 903c694 (inital commit)
