import datetime
from decimal import Decimal
<<<<<<< HEAD
from typing import (
    Any,
    Callable,
    Dict,
    Generator,
    List,
    Tuple,
    Type,
    TypeVar,
    no_type_check,
)
from uuid import UUID

from django.db.models import ManyToManyField
from django.db.models.fields import Field
from django.utils.functional import keep_lazy_text
from pydantic import IPvAnyAddress
from pydantic.fields import FieldInfo, Undefined

from ninja.openapi.schema import OpenAPISchema
=======
from typing import Any, Callable, Dict, List, Tuple, Type, TypeVar, Union, no_type_check
from uuid import UUID

from django.db.models import ManyToManyField
from django.db.models.fields import Field as DjangoField
from pydantic import IPvAnyAddress
from pydantic.fields import FieldInfo
from pydantic_core import PydanticUndefined, core_schema

from ninja.errors import ConfigError
from ninja.openapi.schema import OpenAPISchema
from ninja.types import DictStrAny
>>>>>>> ecbd90b (Initial commit)

__all__ = ["create_m2m_link_type", "get_schema_field", "get_related_field_schema"]


<<<<<<< HEAD
@keep_lazy_text
=======
# keep_lazy seems not needed as .title forces translation anyway
# https://github.com/vitalik/django-ninja/issues/774
# @keep_lazy_text
>>>>>>> ecbd90b (Initial commit)
def title_if_lower(s: str) -> str:
    if s == s.lower():
        return s.title()
    return s


class AnyObject:
    @classmethod
<<<<<<< HEAD
    def __modify_schema__(cls, field_schema: Dict[str, Any]) -> None:
        field_schema.update(type="object")

    @classmethod
    def __get_validators__(cls) -> Generator[Callable, None, None]:
        yield cls.validate

    @classmethod
    def validate(cls, value: Any) -> Any:
=======
    def __get_pydantic_core_schema__(
        cls, source: Any, handler: Callable[..., Any]
    ) -> Any:
        return core_schema.with_info_plain_validator_function(cls.validate)

    @classmethod
    def __get_pydantic_json_schema__(
        cls, schema: Any, handler: Callable[..., Any]
    ) -> DictStrAny:
        return {"type": "object"}

    @classmethod
    def validate(cls, value: Any, _: Any) -> Any:
>>>>>>> ecbd90b (Initial commit)
        return value


TYPES = {
    "AutoField": int,
    "BigAutoField": int,
    "BigIntegerField": int,
    "BinaryField": bytes,
    "BooleanField": bool,
    "CharField": str,
    "DateField": datetime.date,
    "DateTimeField": datetime.datetime,
    "DecimalField": Decimal,
    "DurationField": datetime.timedelta,
    "FileField": str,
    "FilePathField": str,
    "FloatField": float,
    "GenericIPAddressField": IPvAnyAddress,
    "IPAddressField": IPvAnyAddress,
    "IntegerField": int,
    "JSONField": AnyObject,
    "NullBooleanField": bool,
    "PositiveBigIntegerField": int,
    "PositiveIntegerField": int,
    "PositiveSmallIntegerField": int,
    "SlugField": str,
<<<<<<< HEAD
=======
    "SmallAutoField": int,
>>>>>>> ecbd90b (Initial commit)
    "SmallIntegerField": int,
    "TextField": str,
    "TimeField": datetime.time,
    "UUIDField": UUID,
    # postgres fields:
    "ArrayField": List,
    "CICharField": str,
    "CIEmailField": str,
    "CITextField": str,
    "HStoreField": Dict,
}

TModel = TypeVar("TModel")


<<<<<<< HEAD
=======
def register_field(django_field: str, python_type: Any) -> None:
    TYPES[django_field] = python_type


>>>>>>> ecbd90b (Initial commit)
@no_type_check
def create_m2m_link_type(type_: Type[TModel]) -> Type[TModel]:
    class M2MLink(type_):  # type: ignore
        @classmethod
<<<<<<< HEAD
        def __get_validators__(cls):
            yield cls.validate

        @classmethod
        def validate(cls, v):
=======
        def __get_pydantic_core_schema__(cls, source, handler):
            return core_schema.with_info_plain_validator_function(cls._validate)

        @classmethod
        def __get_pydantic_json_schema__(cls, schema, handler):
            json_type = {
                int: "integer",
                str: "string",
                float: "number",
                UUID: "string",
            }[type_]
            return {"type": json_type}

        @classmethod
        def _validate(cls, v: Any, _):
>>>>>>> ecbd90b (Initial commit)
            try:
                return v.pk  # when we output queryset - we have db instances
            except AttributeError:
                return type_(v)  # when we read payloads we have primakey keys

    return M2MLink


@no_type_check
<<<<<<< HEAD
def get_schema_field(field: Field, *, depth: int = 0) -> Tuple:
=======
def get_schema_field(
    field: DjangoField, *, depth: int = 0, optional: bool = False
) -> Tuple:
    "Returns pydantic field from django's model field"
>>>>>>> ecbd90b (Initial commit)
    alias = None
    default = ...
    default_factory = None
    description = None
    title = None
    max_length = None
<<<<<<< HEAD
=======
    nullable = False
>>>>>>> ecbd90b (Initial commit)
    python_type = None

    if field.is_relation:
        if depth > 0:
            return get_related_field_schema(field, depth=depth)

        internal_type = field.related_model._meta.pk.get_internal_type()

<<<<<<< HEAD
        if not field.concrete and field.auto_created or field.null:
            default = None
=======
        if not field.concrete and field.auto_created or field.null or optional:
            default = None
            nullable = True
>>>>>>> ecbd90b (Initial commit)

        alias = getattr(field, "get_attname", None) and field.get_attname()

        pk_type = TYPES.get(internal_type, int)
        if field.one_to_many or field.many_to_many:
            m2m_type = create_m2m_link_type(pk_type)
            python_type = List[m2m_type]  # type: ignore
        else:
            python_type = pk_type

    else:
<<<<<<< HEAD
        field_options = field.deconstruct()[3]  # 3 are the keywords
=======
        _f_name, _f_path, _f_pos, field_options = field.deconstruct()
>>>>>>> ecbd90b (Initial commit)
        blank = field_options.get("blank", False)
        null = field_options.get("null", False)
        max_length = field_options.get("max_length")

        internal_type = field.get_internal_type()
<<<<<<< HEAD
        python_type = TYPES[internal_type]
=======
        try:
            python_type = TYPES[internal_type]
        except KeyError as e:
            msg = [
                f"Do not know how to convert django field '{internal_type}'.",
                "Try from ninja.orm import register_field",
                f"register_field('{internal_type}', <your-python-type>)",
            ]
            raise ConfigError("\n".join(msg)) from e

        if field.primary_key or blank or null or optional:
            default = None
            nullable = True
>>>>>>> ecbd90b (Initial commit)

        if field.has_default():
            if callable(field.default):
                default_factory = field.default
            else:
                default = field.default
<<<<<<< HEAD
        elif field.primary_key or blank or null:
            default = None

    if default_factory:
        default = Undefined

    description = field.help_text
=======

    if default_factory:
        default = PydanticUndefined

    if nullable:
        python_type = Union[python_type, None]  # aka Optional in 3.7+

    description = field.help_text or None
>>>>>>> ecbd90b (Initial commit)
    title = title_if_lower(field.verbose_name)

    return (
        python_type,
        FieldInfo(
            default=default,
            alias=alias,
<<<<<<< HEAD
=======
            validation_alias=alias,
            serialization_alias=alias,
>>>>>>> ecbd90b (Initial commit)
            default_factory=default_factory,
            title=title,
            description=description,
            max_length=max_length,
        ),
    )


@no_type_check
<<<<<<< HEAD
def get_related_field_schema(field: Field, *, depth: int) -> Tuple[OpenAPISchema]:
=======
def get_related_field_schema(field: DjangoField, *, depth: int) -> Tuple[OpenAPISchema]:
>>>>>>> ecbd90b (Initial commit)
    from ninja.orm import create_schema

    model = field.related_model
    schema = create_schema(model, depth=depth - 1)
    default = ...
    if not field.concrete and field.auto_created or field.null:
        default = None
    if isinstance(field, ManyToManyField):
        schema = List[schema]  # type: ignore

    return (
        schema,
        FieldInfo(
            default=default,
            description=field.help_text,
            title=title_if_lower(field.verbose_name),
        ),
    )
