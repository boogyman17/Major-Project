"""
Since "Model" word would be very confusing when used in django context, this
module basically makes an alias for it named "Schema" and adds extra whistles to
be able to work with django querysets and managers.

The schema is a bit smarter than a standard pydantic Model because it can handle
dotted attributes and resolver methods. For example::


    class UserSchema(User):
        name: str
        initials: str
        boss: str = Field(None, alias="boss.first_name")

        @staticmethod
        def resolve_name(obj):
            return f"{obj.first_name} {obj.last_name}"

<<<<<<< HEAD
<<<<<<< HEAD
        def resolve_initials(self, obj):
            return "".join(n[:1] for n in self.name.split())

"""
from typing import Any, Callable, Dict, Type, TypeVar, Union, no_type_check
=======
"""

import warnings
from typing import (
    Any,
    Callable,
    Dict,
    Type,
    TypeVar,
    Union,
    no_type_check,
)
>>>>>>> ecbd90b (Initial commit)
=======
        def resolve_initials(self, obj):
            return "".join(n[:1] for n in self.name.split())

"""
from typing import Any, Callable, Dict, Type, TypeVar, Union, no_type_check
>>>>>>> 903c694 (inital commit)

import pydantic
from django.db.models import Manager, QuerySet
from django.db.models.fields.files import FieldFile
from django.template import Variable, VariableDoesNotExist
<<<<<<< HEAD
<<<<<<< HEAD
from pydantic import BaseModel, Field, validator
from pydantic.main import ModelMetaclass
from pydantic.utils import GetterDict

pydantic_version = list(map(int, pydantic.VERSION.split(".")[:2]))
assert pydantic_version >= [1, 6], "Pydantic 1.6+ required"
=======
from pydantic import BaseModel, Field, ValidationInfo, model_validator, validator
from pydantic._internal._model_construction import ModelMetaclass
from pydantic.functional_validators import ModelWrapValidatorHandler
from pydantic.json_schema import GenerateJsonSchema, JsonSchemaValue
from typing_extensions import dataclass_transform

from ninja.signature.utils import get_args_names, has_kwargs
from ninja.types import DictStrAny

pydantic_version = list(map(int, pydantic.VERSION.split(".")[:2]))
assert pydantic_version >= [2, 0], "Pydantic 2.0+ required"
>>>>>>> ecbd90b (Initial commit)
=======
from pydantic import BaseModel, Field, validator
from pydantic.main import ModelMetaclass
from pydantic.utils import GetterDict

pydantic_version = list(map(int, pydantic.VERSION.split(".")[:2]))
assert pydantic_version >= [1, 6], "Pydantic 1.6+ required"
>>>>>>> 903c694 (inital commit)

__all__ = ["BaseModel", "Field", "validator", "DjangoGetter", "Schema"]

S = TypeVar("S", bound="Schema")


<<<<<<< HEAD
<<<<<<< HEAD
class DjangoGetter(GetterDict):
    __slots__ = ("_obj", "_schema_cls")

    def __init__(self, obj: Any, schema_cls: "Type[Schema]"):
        self._obj = obj
        self._schema_cls = schema_cls

    def __getitem__(self, key: str) -> Any:
        resolver = self._schema_cls._ninja_resolvers.get(key)
        if resolver:
            item = resolver(getter=self)
        else:
            try:
                item = getattr(self._obj, key)
            except AttributeError:
                try:
                    # item = attrgetter(key)(self._obj)
                    item = Variable(key).resolve(self._obj)
                    # TODO: Variable(key) __init__ is actually slower than
                    #       resolve - so it better be cached
                except VariableDoesNotExist as e:
                    raise KeyError(key) from e
        return self._convert_result(item)

    def get(self, key: Any, default: Any = None) -> Any:
        try:
            return self[key]
        except KeyError:
            return default
=======
class DjangoGetter:
    __slots__ = ("_obj", "_schema_cls", "_context", "__dict__")
=======
class DjangoGetter(GetterDict):
    __slots__ = ("_obj", "_schema_cls")
>>>>>>> 903c694 (inital commit)

    def __init__(self, obj: Any, schema_cls: "Type[Schema]"):
        self._obj = obj
        self._schema_cls = schema_cls

    def __getitem__(self, key: str) -> Any:
        resolver = self._schema_cls._ninja_resolvers.get(key)
        if resolver:
            item = resolver(getter=self)
        else:
            try:
                item = getattr(self._obj, key)
            except AttributeError:
                try:
                    # item = attrgetter(key)(self._obj)
                    item = Variable(key).resolve(self._obj)
                    # TODO: Variable(key) __init__ is actually slower than
                    #       resolve - so it better be cached
                except VariableDoesNotExist as e:
                    raise KeyError(key) from e
        return self._convert_result(item)

<<<<<<< HEAD
    # def get(self, key: Any, default: Any = None) -> Any:
    #     try:
    #         return self[key]
    #     except KeyError:
    #         return default
>>>>>>> ecbd90b (Initial commit)
=======
    def get(self, key: Any, default: Any = None) -> Any:
        try:
            return self[key]
        except KeyError:
            return default
>>>>>>> 903c694 (inital commit)

    def _convert_result(self, result: Any) -> Any:
        if isinstance(result, Manager):
            return list(result.all())

        elif isinstance(result, getattr(QuerySet, "__origin__", QuerySet)):
            return list(result)

        if callable(result):
            return result()

        elif isinstance(result, FieldFile):
            if not result:
                return None
            return result.url

        return result

<<<<<<< HEAD
<<<<<<< HEAD

class Resolver:
    __slots__ = ("_func", "_static")
    _static: bool
    _func: Any
=======
    def __repr__(self) -> str:
        return f"<DjangoGetter: {repr(self._obj)}>"

=======
>>>>>>> 903c694 (inital commit)

class Resolver:
    __slots__ = ("_func", "_static")
    _static: bool
    _func: Any
<<<<<<< HEAD
    _takes_context: bool
>>>>>>> ecbd90b (Initial commit)
=======
>>>>>>> 903c694 (inital commit)

    def __init__(self, func: Union[Callable, staticmethod]):
        if isinstance(func, staticmethod):
            self._static = True
            self._func = func.__func__
        else:
            self._static = False
            self._func = func

<<<<<<< HEAD
<<<<<<< HEAD
    def __call__(self, getter: DjangoGetter) -> Any:
        if self._static:
            return self._func(getter._obj)
        return self._func(self._fake_instance(getter), getter._obj)

    def _fake_instance(self, getter: DjangoGetter) -> "Schema":
        """
        Generate a partial schema instance that can be used as the ``self``
        attribute of resolver functions.
        """

        class PartialSchema(Schema):
            def __getattr__(self, key: str) -> Any:
                value = getter[key]
                field = getter._schema_cls.__fields__[key]
                value = field.validate(value, values={}, loc=key, cls=None)[0]
                return value

        return PartialSchema()


=======
        arg_names = get_args_names(self._func)
        self._takes_context = has_kwargs(self._func) or "context" in arg_names

=======
>>>>>>> 903c694 (inital commit)
    def __call__(self, getter: DjangoGetter) -> Any:
        if self._static:
            return self._func(getter._obj)
        return self._func(self._fake_instance(getter), getter._obj)

    def _fake_instance(self, getter: DjangoGetter) -> "Schema":
        """
        Generate a partial schema instance that can be used as the ``self``
        attribute of resolver functions.
        """

        class PartialSchema(Schema):
            def __getattr__(self, key: str) -> Any:
                value = getter[key]
                field = getter._schema_cls.__fields__[key]
                value = field.validate(value, values={}, loc=key, cls=None)[0]
                return value

        return PartialSchema()


<<<<<<< HEAD
@dataclass_transform(kw_only_default=True, field_specifiers=(Field,))
>>>>>>> ecbd90b (Initial commit)
=======
>>>>>>> 903c694 (inital commit)
class ResolverMetaclass(ModelMetaclass):
    _ninja_resolvers: Dict[str, Resolver]

    @no_type_check
    def __new__(cls, name, bases, namespace, **kwargs):
        resolvers = {}

        for base in reversed(bases):
            base_resolvers = getattr(base, "_ninja_resolvers", None)
            if base_resolvers:
                resolvers.update(base_resolvers)
        for attr, resolve_func in namespace.items():
            if not attr.startswith("resolve_"):
                continue
            if (
                not callable(resolve_func)
                # A staticmethod isn't directly callable in Python <=3.9.
                and not isinstance(resolve_func, staticmethod)
            ):
                continue  # pragma: no cover
            resolvers[attr[8:]] = Resolver(resolve_func)

        result = super().__new__(cls, name, bases, namespace, **kwargs)
        result._ninja_resolvers = resolvers
        return result


<<<<<<< HEAD
<<<<<<< HEAD
class Schema(BaseModel, metaclass=ResolverMetaclass):
    class Config:
        orm_mode = True
        getter_dict = DjangoGetter

    @classmethod
    def from_orm(cls: Type[S], obj: Any) -> S:
        getter_dict = cls.__config__.getter_dict
        obj = (
            # DjangoGetter also needs the class so it can find resolver methods.
            getter_dict(obj, cls)
            if issubclass(getter_dict, DjangoGetter)
            else getter_dict(obj)
        )
        return super().from_orm(obj)

    @classmethod
    def _decompose_class(cls, obj: Any) -> GetterDict:
        # This method has backported logic from Pydantic 1.9 and is no longer
        # needed once that is the minimum version.
        if isinstance(obj, GetterDict):
            return obj
        return super()._decompose_class(obj)  # pragma: no cover
=======
class NinjaGenerateJsonSchema(GenerateJsonSchema):
    def default_schema(self, schema: Any) -> JsonSchemaValue:
        # Pydantic default actually renders null's and default_factory's
        # which really breaks swagger and django model callable defaults
        # so here we completely override behavior
        json_schema = self.generate_inner(schema["schema"])

        default = None
        if "default" in schema and schema["default"] is not None:
            default = self.encode_default(schema["default"])

        if "$ref" in json_schema:
            # Since reference schemas do not support child keys, we wrap the reference schema in a single-case allOf:
            result = {"allOf": [json_schema]}
        else:
            result = json_schema

        if default is not None:
            result["default"] = default

        return result


=======
>>>>>>> 903c694 (inital commit)
class Schema(BaseModel, metaclass=ResolverMetaclass):
    class Config:
        orm_mode = True
        getter_dict = DjangoGetter

    @classmethod
    def from_orm(cls: Type[S], obj: Any) -> S:
        getter_dict = cls.__config__.getter_dict
        obj = (
            # DjangoGetter also needs the class so it can find resolver methods.
            getter_dict(obj, cls)
            if issubclass(getter_dict, DjangoGetter)
            else getter_dict(obj)
        )
<<<<<<< HEAD
        return cls.json_schema()
>>>>>>> ecbd90b (Initial commit)
=======
        return super().from_orm(obj)

    @classmethod
    def _decompose_class(cls, obj: Any) -> GetterDict:
        # This method has backported logic from Pydantic 1.9 and is no longer
        # needed once that is the minimum version.
        if isinstance(obj, GetterDict):
            return obj
        return super()._decompose_class(obj)  # pragma: no cover
>>>>>>> 903c694 (inital commit)
